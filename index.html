<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Chaos Theory Simulation</title>
    <style>
        body { margin: 0; }
        canvas { width: 100%; height: 100% }
    </style>
</head>
<body>

<script src="js/dat.gui.min.js"></script>
<script src="js/three.js"></script>
<script src="js/OrbitControls.js"></script>

<script type="x-shader/x-vertex" id="vertexshader">
        attribute float size;
        varying vec3 vColor;
        void main() {
            vColor = color;
            vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
            gl_PointSize = size * ( 300.0 / -mvPosition.z );
            gl_Position = projectionMatrix * mvPosition;
        }
</script>

<script type="x-shader/x-fragment" id="fragmentshader">
    uniform sampler2D texture;
    varying vec3 vColor;
    void main() {
        gl_FragColor = vec4( vColor, 1.0 );
        gl_FragColor = gl_FragColor * texture2D( texture, gl_PointCoord );
    }
</script>

<script>

    let time_elapsed = -1;
    let time_end = 1;
    let time_reset = 0.1;
    let speed = 0.1;
    let stopSpeed = false;
    let waitRender = true;

    let a = 10.0, b = 28.0, c = 8.0 / 3.0;

    let scene = new THREE.Scene();
    let camera = new THREE.PerspectiveCamera( 75, window.innerWidth/window.innerHeight, 5, 3500 );
    let renderer = new THREE.WebGLRenderer();
    renderer.setSize( window.innerWidth, window.innerHeight );
    renderer.setPixelRatio( window.devicePixelRatio );
    renderer.setSize( window.innerWidth, window.innerHeight );
    document.body.appendChild( renderer.domElement );
    let controls = new THREE.OrbitControls(camera, renderer.domElement);

    let positions;
    let oldPositions;



    let animate = function () {
        requestAnimationFrame( animate );
        camera.updateProjectionMatrix();
        controls.update();


        time_elapsed += speed;
        if(time_elapsed >= time_end) {
            console.log(time_elapsed);
            time_elapsed = time_reset;

        }

        //scene.rotation.y = Date.now() / 2000;
        if(!stopSpeed) {
            experiment1();
        }
        /*if(waitRender === true) {
            experiment1();
        }*/


        renderer.render( scene, camera );
    };

    /** Particle System Setup */
    function createParticleSystem() {

        console.log(scene.children);

        // create the particle variables
        let num_Particles = 2000,
            particlesGeo = new THREE.BufferGeometry(),
            /*pMaterial = new THREE.ShaderMaterial( {
                /!*uniforms: uniforms,*!/
                vertexShader: document.getElementById( 'vertexshader' ).textContent,
                fragmentShader: document.getElementById( 'fragmentshader' ).textContent,
                blending: THREE.AdditiveBlending,
                depthTest: false,
                transparent: true,
                vertexColors: true
            } ),*/
            pMaterial = new THREE.PointsMaterial( { size: 20, vertexColors: THREE.VertexColors, depthTest: false, sizeAttenuation: false } ),
            color = new THREE.Color();

        let positions = [];
        let colors = [];
        let sizes = [];

        let x0 = 1,
            y0 = 0,
            z0 = 0;
        let x1, y1, z1, h = 0.01;

        // now create the individual particles
        for (let p = 0; p < num_Particles; p++) {

            x1 = x0 + h * a * (y0 - x0);
            y1 = y0 + h * (x0 * (b - z0) - y0);
            z1 = z0 + h * (x0 * y0 - c * z0);
            x0 = x1;
            y0 = y1;
            z0 = z1;

            color.setHSL( p / num_Particles, 1.0, 0.5 );
            colors.push( color.r, color.g, color.b );

            positions.push( Math.floor(x0));
            positions.push(Math.floor(y0));
            positions.push(Math.floor(z0));
            sizes.push( 20 );

            // add it to the geometry
        }

        console.log("A changed to " + a);

        particlesGeo.addAttribute( 'position', new THREE.Float32BufferAttribute( positions, 3 ).setDynamic( true ) );
        particlesGeo.addAttribute( 'color', new THREE.Float32BufferAttribute( colors, 3 ) );
        particlesGeo.addAttribute( 'size', new THREE.Float32BufferAttribute( sizes, 1 ).setDynamic( true ) );

        //particlesGeo.computeBoundingSphere();

        // create the particle system
        let particleSystem = new THREE.Points(
            particlesGeo,
            pMaterial);

        particleSystem.sortParticles = true;

        particleSystem.rotation.x = -Math.PI/10;
        particleSystem.rotation.y = 0;

        // add it to the scene
        scene.add(particleSystem);

        console.log(scene.children);
    }

    /** Motion for Particle System */
    function experiment1() {
        if(scene.children.length) {

            positions = scene.children[0].geometry.attributes.position.array;

            let posCounter = 0;

            for(let i = positions.length-3; i < positions.length; i++) {
                positions[i] = oldPositions[i] + (oldPositions[posCounter++] - oldPositions[i])*(time_elapsed);
            }

            for (let i = 0; i < positions.length-3; i++) {
                positions[i] = oldPositions[i] + (oldPositions[i+3] - oldPositions[i])*(time_elapsed);
            }

            scene.children[0].geometry.attributes.position.needsUpdate = true;
        }
    }

    let setup = function() {

        /*this.startTime = -1;*/
        this.endTime = time_end;
        this.resetTime = time_reset;
        this.particleSpeed = speed;
        this.stopSpeed = stopSpeed;
        this.a_value = a;
        this.b_value = b;
        this.c_value = c;

        createParticleSystem();

        positions = scene.children[0].geometry.attributes.position.array;

        oldPositions = [...positions];

        camera.position.set(-62, 40, 52);
        camera.rotation.set(-1.3, -0.92, -1.2);

        animate();

        /** Variable width/height canvas Listener function */
        window.addEventListener('resize', re => {
            const width = window.innerWidth;
            const height = window.innerHeight;

            renderer.setPixelRatio( window.devicePixelRatio );
            renderer.setSize(width, height);
            camera.aspect = width / height;
            camera.updateProjectionMatrix();
        });
    };

    function updateParticleSystem() {
        waitRender = false;
        // create the particle variables
        let num_Particles = 2000,
            particlesGeo = scene.children[0].geometry;

        let positions = particlesGeo.attributes.position.array;

        let x0 = 1,
            y0 = 0,
            z0 = 0;
        let x1, y1, z1, h = 0.01;

        let posCounter = 0;
        // now create the individual particles
        for (let p = 0; p < num_Particles; p++) {

            x1 = x0 + h * a * (y0 - x0);
            y1 = y0 + h * (x0 * (b - z0) - y0);
            z1 = z0 + h * (x0 * y0 - c * z0);
            x0 = x1;
            y0 = y1;
            z0 = z1;

            positions[posCounter++] = (Math.floor(x0));
            positions[posCounter++] = (Math.floor(y0));
            positions[posCounter++] = (Math.floor(z0));
            // add it to the geometry
        }

        scene.children[0].geometry.attributes.position.needsUpdate = true;

        console.log("A changed to " + a);

        waitRender = true;
    }

    window.onload = function() {
        let text = new setup();
        let gui = new dat.GUI();
        /*gui.add(text, 'startTime', -5, 1).listen().onChange(value => {
            time_elapsed = value;
        });*/
        gui.add(text, 'resetTime', -20, 20).listen().onChange(value => {
            time_reset = value;
        });
        gui.add(text, 'endTime', -20, 20).listen().onChange(value => {
            time_end = value;
        });
        gui.add(text, 'particleSpeed', -.05, .5).step(.001).listen().onChange(value => {
            speed = value;
        });
        gui.add(text, 'stopSpeed').listen().onChange(value => {
            stopSpeed = value;
        });
        gui.add(text, 'a_value').onChange(value => {
            a = value;

            updateParticleSystem();
            positions = scene.children[0].geometry.attributes.position.array;
            oldPositions = [...positions];
        });
        gui.add(text, 'b_value').onChange(value => {
            b = value;
            updateParticleSystem();
            positions = scene.children[0].geometry.attributes.position.array;
            oldPositions = [...positions];
        });
        gui.add(text, 'c_value').onChange(value => {
            c = value;
            updateParticleSystem();
            positions = scene.children[0].geometry.attributes.position.array;
            oldPositions = [...positions];
        });
    };
</script>
</body>
</html>